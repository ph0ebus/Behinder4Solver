#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/evp.h>
#include <pthread.h>

#define AES_KEY_LENGTH 16  // 定义AES密钥长度
#define XOR_KEY_LENGTH 16  // 定义XOR密钥长度
#define NUM_THREADS 16     // 定义线程数量
#define DEFAULT_AES_MODE 3 // 定义解密算法模式: 默认AES解密
#define DEFAULT_XOR_MODE 4 // 定义解密算法模式: 默认XOR解密

// 用于多线程传入多个参数
typedef struct func_para
{
    int thread_id; // 进程号
    char *data;    // 加密数据
    char **lines;  // 用于爆破的字典
    int num_lines; // 字典中元素数量
    int mode;      // 解密算法
} para;

/**
 * 展示项目banner
 *
 */
void banner()
{
    char banner[600];
    const char *VERSION = "v1.1";
    sprintf(banner, "/***\n *       ___      _     _           _           _  _   __            _           \n *      / __\\ ___| |__ (_)_ __   __| | ___ _ __| || | / _\\ _____   _| | ___ _ __ \n *     /__\\/// _ | \'_ \\| | \'_ \\ / _` |/ _ | \'__| || |_\\ \\ / _ \\ \\ / | |/ _ | \'__|\n *    / \\/  |  __| | | | | | | | (_| |  __| |  |__   __\\ | (_) \\ V /| |  __| |   \n *    \\_____/\\___|_| |_|_|_| |_|\\__,_|\\___|_|     |_| \\__/\\___/ \\_/ |_|\\___|_|   \n *                                                                         %s by ph0ebus \n */\n", VERSION);
    printf("%s", banner);
    printf("Introduction:\n  Used to decrypt traffic generated by Behinder4. (Currently, \033[32mdefault_aes\033[0m and \033[32mdefault_xor\033[0m is supported)\n  By default, use \033[33mdict.txt\033[0m from the same directory to read line by line as the dictionary\n");
}

/**
 * 读取文件内容第一行作为输入流
 *
 * char *filename  要读取的文件名
 *
 * char **data     接收读取的文件内容
 */
int file2input(char *filename, char **data)
{
    FILE *file;
    size_t len = 0;
    int read;

    // 打开文件
    file = fopen(filename, "r");
    if (file == NULL)
    {
        perror("Can't open this file\n");
        return -1;
    }

    // 读取第一行
    read = getline(&*data, &len, file);
    if (read == -1)
    {
        perror("read failture\n");
        fclose(file);
        return -1;
    }

    // 关闭文件
    fclose(file);
    return 0;
}

/**
 * 将字符流以二进制形式写入文件
 *
 * char *filename   写入的文件名
 *
 * char *data       要写入的数据流
 *
 * int data_size    写入数据流的大小
 */
int out2file(char *filename, char *data, int data_size)
{
    FILE *fp;
    // 打开文件以二进制写入模式
    fp = fopen(filename, "wb");
    if (fp == NULL)
    {
        perror("Error opening file");
        return -1;
    }

    // 将数据写入文件
    fwrite(data, sizeof(char), data_size, fp);
    // 关闭文件
    fclose(fp);
    printf("[+] Data written to \033[33m%s\033[0m successfully.\n", filename);
    return 0;
}

/**
 * base64解码
 *
 * unsigned char *code   base64编码后的字符串
 *
 * int *length           接收base64解码后的字符流长度
 *
 * return base64解码后的原文
 */
unsigned char *base64_decode(unsigned char *code, int *length)
{
    // 根据base64表，以字符找到对应的十进制数据
    int table[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                   0, 0, 0, 0, 0, 0, 0, 62, 0, 0, 0,
                   63, 52, 53, 54, 55, 56, 57, 58,
                   59, 60, 61, 0, 0, 0, 0, 0, 0, 0, 0,
                   1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
                   13, 14, 15, 16, 17, 18, 19, 20, 21,
                   22, 23, 24, 25, 0, 0, 0, 0, 0, 0, 26,
                   27, 28, 29, 30, 31, 32, 33, 34, 35,
                   36, 37, 38, 39, 40, 41, 42, 43, 44,
                   45, 46, 47, 48, 49, 50, 51};
    long len;
    long str_len;
    unsigned char *res;
    int i, j;

    // 计算解码后的字符串长度
    len = strlen(code);
    // 判断编码后的字符串后是否有=
    if (strstr(code, "=="))
        str_len = len / 4 * 3 - 2;
    else if (strstr(code, "="))
        str_len = len / 4 * 3 - 1;
    else
        str_len = len / 4 * 3;

    res = malloc(sizeof(unsigned char) * str_len + 1);
    *length = str_len;
    res[str_len] = '\0';

    // 以4个字符为一位进行解码
    for (i = 0, j = 0; i < len - 2; j += 3, i += 4)
    {
        res[j] = ((unsigned char)table[code[i]]) << 2 | (((unsigned char)table[code[i + 1]]) >> 4);           // 取出第一个字符对应base64表的十进制数的前6位与第二个字符对应base64表的十进制数的后2位进行组合
        res[j + 1] = (((unsigned char)table[code[i + 1]]) << 4) | (((unsigned char)table[code[i + 2]]) >> 2); // 取出第二个字符对应base64表的十进制数的后4位与第三个字符对应bas464表的十进制数的后4位进行组合
        res[j + 2] = (((unsigned char)table[code[i + 2]]) << 6) | ((unsigned char)table[code[i + 3]]);        // 取出第三个字符对应base64表的十进制数的后2位与第4个字符进行组合
    }

    return res;
}

/**
 * 异或算法解密
 *
 * unsigned char* data    加密数据
 *
 * size_t data_len        加密数据长度
 *
 * const char* key        密钥
 */
unsigned char *xor_decode(unsigned char *data, size_t data_len, const unsigned char *key)
{
    size_t key_len = strlen(key);
    unsigned char *result = (unsigned char *)malloc((data_len + 1) * sizeof(char));

    // 进行异或操作
    for (size_t i = 0; i < data_len; ++i)
    {
        result[i] = data[i] ^ key[(i + 1) & 15];
    }

    result[data_len] = '\0';
    return result;
}

unsigned char *default_xor_decode(unsigned char *enc, int *enc_len, unsigned char *key)
{
    if (strlen(key) != XOR_KEY_LENGTH)
    {
        fprintf(stderr, "[-] Invalid key length: %d bytes\n", strlen(key));
        return NULL;
    }
    unsigned char *base64_de = base64_decode(enc, enc_len);
    char *result = xor_decode(base64_de, *enc_len, key);
    if (result == NULL)
    {
        fprintf(stderr, "[-] Unable to decrypt input with these parameters.\n");
    }
    return result;
}

/**
 * EVP框架实现AES ECB模式解密算法
 *
 * unsigned char *enc   密文
 *
 * int enc_len          密文长度
 *
 * unsigned char *key   密钥
 *
 * return 解密后的原文，如果解密失败或参数无效，返回NULL
 */
unsigned char *aes_decode(unsigned char *enc, int enc_len, unsigned char *key)
{
    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    int encLen = 0;
    int outlen = 0;

    int encSize = enc_len;
    unsigned char result[encSize + EVP_MAX_BLOCK_LENGTH];

    if (!EVP_CipherInit_ex(ctx, EVP_aes_128_ecb(), NULL, key, NULL, 0))
    {
        // 解密初始化失败
        fprintf(stderr, "EVP_CipherInit_ex failed\n");
        EVP_CIPHER_CTX_free(ctx);
        return NULL;
    }
    EVP_CIPHER_CTX_set_padding(ctx, 1); // 启用PKCS5Padding

    if (!EVP_CipherUpdate(ctx, result, &outlen, enc, encSize))
    {
        // 解密失败
        fprintf(stderr, "EVP_CipherUpdate failed\n");
        EVP_CIPHER_CTX_free(ctx);
        return NULL;
    }
    encLen = outlen;

    if (!EVP_CipherFinal(ctx, result + outlen, &outlen))
    {
        // 解密失败
        fprintf(stderr, "EVP_CipherFinal failed\n");
        EVP_CIPHER_CTX_free(ctx);
        return NULL;
    }
    encLen += outlen;
    EVP_CIPHER_CTX_free(ctx);

    unsigned char *decrypted = malloc(encLen);
    if (decrypted == NULL)
    {
        // 内存分配失败
        fprintf(stderr, "Memory allocation failed\n");
        return NULL;
    }
    memcpy(decrypted, result, encLen);

    return decrypted;
}

/**
 * default_aes传输协议流量解密
 *
 * char *data    加密流量内容
 *
 * int *str_len  接收解密后明文内容长度
 *
 * char *key     密钥
 */
unsigned char *default_aes_decode(char *data, int *str_len, char *key)
{
    if (strlen(key) != AES_KEY_LENGTH)
    {
        fprintf(stderr, "[-] Invalid key length: %d bytes\n[-] The following algorithms will be used based on the size of the key:\n  16 bytes = AES-128\n  24 bytes = AES-192\n  32 bytes = AES-256\n", strlen(key));
        return NULL;
    }
    unsigned char *base64_de = base64_decode(data, str_len);
    char *result = aes_decode(base64_de, *str_len, key);
    if (result == NULL)
    {
        fprintf(stderr, "[-] Unable to decrypt input with these parameters.\n");
    }
    return result;
}

/**
 * 基于 OpenSSL 库实现 MD5 摘要算法
 *
 * unsigned char *data   需要摘要的数据
 *
 * size_t data_len       数据的长度
 *
 * unsigned char *result 生成的 MD5 摘要结果字符串
 */
void md5_enc(unsigned char *data, size_t data_len, unsigned char *result)
{
    EVP_MD_CTX *mdctx;
    const EVP_MD *md;

    // 创建 MD5 摘要上下文
    mdctx = EVP_MD_CTX_new();
    if (mdctx == NULL)
    {
        fprintf(stderr, "Failed to create MD5 context\n");
        return;
    }

    // 设置 MD5 摘要算法
    md = EVP_md5();
    if (md == NULL)
    {
        fprintf(stderr, "Failed to get MD5 digest algorithm\n");
        EVP_MD_CTX_free(mdctx);
        return;
    }

    // 初始化 MD5 摘要计算
    if (EVP_DigestInit_ex(mdctx, md, NULL) != 1)
    {
        fprintf(stderr, "Failed to initialize MD5 digest calculation\n");
        EVP_MD_CTX_free(mdctx);
        return;
    }

    // 更新摘要计算
    if (EVP_DigestUpdate(mdctx, data, data_len) != 1)
    {
        fprintf(stderr, "Failed to update MD5 digest calculation\n");
        EVP_MD_CTX_free(mdctx);
        return;
    }

    // 获取摘要结果长度
    unsigned char *buffer = malloc(EVP_MAX_MD_SIZE);
    unsigned int buffer_len = 0;
    if (EVP_DigestFinal_ex(mdctx, buffer, &buffer_len) != 1)
    {
        fprintf(stderr, "Failed to finalize MD5 digest calculation\n");
        EVP_MD_CTX_free(mdctx);
        return;
    }

    // 将MD5结果转换为字符串
    for (int i = 0; i < 16; i++)
    {
        sprintf(result + (i * 2), "%02x", buffer[i]);
    }

    EVP_MD_CTX_free(mdctx);
    free(buffer);
}

/**
 * 加载用于爆破的密钥字典, 逐行保存到数组中并返回
 *
 * const char *filename  密钥字典文件名
 *
 * return 保存文件内容的字符串数组，如果读取失败返回NULL
 */
char **load_key_dict(const char *filename)
{
    FILE *file = fopen(filename, "r");
    if (file == NULL)
    {
        fprintf(stderr, "Failed to open file: %s\n", filename);
        return NULL;
    }

    // 统计文件行数
    int line_count = 0;
    char ch;
    while ((ch = fgetc(file)) != EOF)
    {
        if (ch == '\n')
        {
            line_count++;
        }
    }
    printf("[+] dict length: %d\n", line_count);
    rewind(file);

    // 创建字符串数组
    char **lines = malloc((line_count + 1) * sizeof(char *));
    if (lines == NULL)
    {
        fprintf(stderr, "Failed to allocate memory\n");
        fclose(file);
        return NULL;
    }

    // 逐行读取文件内容并保存到数组中
    char buffer[256];
    int i = 0;
    while (fgets(buffer, sizeof(buffer), file) != NULL)
    {
        char *line = strtok(buffer, "\n");
        if (line == NULL || strlen(line) == 0)
        {
            continue; // 跳过空行
        }
        int length = strlen(line);
        // 分配内存保存当前行的内容
        lines[i] = malloc((length + 1) * sizeof(char));
        if (lines[i] == NULL)
        {
            fprintf(stderr, "Failed to allocate memory\n");
            fclose(file);

            // 释放已分配的内存
            for (int j = 0; j < i; j++)
            {
                free(lines[j]);
            }
            free(lines);

            return NULL;
        }
        // 复制当前行的内容到数组中
        strcpy(lines[i], line);
        i++;
    }
    lines[i] = NULL;

    fclose(file);
    return lines;
}

/**
 * 密钥爆破
 */
void *crack_key(void *arg)
{
    para *p = (para *)arg;
    int thread_id = p->thread_id;
    // printf("thread_id_func = %d\n",thread_id);
    int num_lines = p->num_lines;
    char **lines = p->lines;
    char *enc = p->data;
    int start = thread_id * (num_lines / NUM_THREADS);
    int end = (thread_id + 1) * (num_lines / NUM_THREADS);

    if (thread_id == NUM_THREADS - 1)
        end = num_lines;

    // printf("%d -- -- start %d end %d \n", thread_id,start,end);

    for (int i = start; i < end; i++)
    {
        char *line = lines[i];
        // printf("%d -> %s\n", thread_id, line);

        char md5_result[33];
        md5_enc(line, strlen(line), md5_result);
        char key[17];
        strncpy(key, md5_result, 16);
        int str_len;
        unsigned char *decrypted_data;
        if (p->mode == DEFAULT_AES_MODE)
        {
            decrypted_data = default_aes_decode(enc, &str_len, key);
        }
        else if (p->mode == DEFAULT_XOR_MODE)
        {
            decrypted_data = default_xor_decode(enc, &str_len, key);
        }
        //  这里调用你的解密函数 default_aes_decode

        if (decrypted_data != NULL)
        {
            int flag = 1;
            // 过滤密钥不正确但能解密出不可见字符流的情况
            for (size_t i = 0; i < str_len / 4; i++)
            {
                if (decrypted_data[i] < 32 || decrypted_data[i] > 126)
                {
                    flag = 0;
                    break;
                }
            }
            // java class magic num
            if (decrypted_data[0] == 202 && decrypted_data[1] == 254 && decrypted_data[2] == 186 && decrypted_data[3] == 190)
            {
                printf("[+] Maybe it is java class...");
                flag = 1;
            }
            if (flag == 0)
            {
                continue;
            }
            printf("[+] Finding Password: \033[31m%s\033[0m\n", line);
            printf("[+] Thread %d found the key: \033[31m%s\033[0m\n", thread_id, key);

            printf("[+] Decrypted data: \n");

            for (size_t i = 0; i < str_len; i++)
            {
                printf("%02x", decrypted_data[i]);
            }

            printf("\n");
            out2file("output.bin", decrypted_data, str_len);
            free(decrypted_data);
            break;
        }
    }

    pthread_exit(NULL);
}

int main()
{
    banner();
    char choice = 0;
    printf("[+] pls input decrypt mode: \n");
    printf("- Normal decrypt with key: \n    1. default_aes\n    2. default_xor\n- Bruteforce decrypt with dict: \n    3. default_aes\n    4. default_xor\n");
    printf("> ");
    scanf("%d", &choice);

    // 加载文件的内容
    char *enc;
    // 无文件则直接用户输入
    if (file2input("./input.txt", &enc) == -1)
    {
        printf("[+] Loading data from file failed. Can't find input.txt\n");
        printf("[+] pls input your encrypted data (Base64 String): \n");
        printf("> ");
        enc = (char *)malloc(sizeof(char) * 2048);
        if (enc == NULL)
        {
            fprintf(stderr, "[-] Failed to allocate memory\n");
            return -1;
        }
        scanf("%s", enc);
    }
    // 有文件则优先加载文件内容
    else
    {
        printf("[+] Successfully loaded data from file \033[33minput.txt\033[0m, skipping user input\n");
    }

    switch (choice)
    {
    // 有密钥的情况
    case 1:
    case 2:
        printf("[+] pls input your key (UTF-8): \n");
        printf("> ");
        char key[17];
        scanf("%s", &key);
        int str_len;
        unsigned char *result;
        if (choice == 1)
        {
            result = default_aes_decode(enc, &str_len, key);
        }
        else
        {
            result = default_xor_decode(enc, &str_len, key);
        }
        if (result != NULL)
        {
            for (size_t i = 0; i < str_len; i++)
            {
                printf("%02x", result[i]);
            }
            printf("\n");
            out2file("output.bin", result, str_len);
        }
        else
        {
            printf("[-] Unable decrypt with these parameter\n");
        }
        break;
    // 无密钥爆破
    case 3:
    case 4:
        char *dictname = "dict.txt";
        char **lines = load_key_dict(dictname);
        char **tmp = lines;
        if (lines == NULL)
        {
            printf("[-] Failed to load key dictionary\n");
            return 1;
        }
        printf("[+] success load dict: %s\n", dictname);
        para params[NUM_THREADS];
        int num_lines = 0;
        while (*lines != NULL)
        {
            num_lines++;
            lines++;
        }
        // 恢复指针偏移
        lines = tmp;
        // 创建线程数组
        pthread_t threads[NUM_THREADS];
        int thread_ids[NUM_THREADS];
        printf("[+] Successfully set to %d threads for brute force cracking\n", NUM_THREADS);

        // 创建线程并开始密钥爆破
        for (int i = 0; i < NUM_THREADS; i++)
        {
            thread_ids[i] = i;
            params[i].thread_id = i;
            params[i].num_lines = num_lines;
            params[i].lines = lines;
            params[i].data = enc;
            params[i].mode = choice;
            int result = pthread_create(&threads[i], NULL, crack_key, &params[i]);
            if (result != 0)
            {
                printf("[-] Error creating thread %d. Exiting...\n", i);
                return 1;
            }
        }

        // 等待所有线程完成
        for (int i = 0; i < NUM_THREADS; i++)
        {
            pthread_join(threads[i], NULL);
        }

        // 释放内存
        for (int j = 0; lines[j] != NULL; j++)
        {
            free(lines[j]);
        }
        free(lines);
        break;
    // 其他选择
    default:
        fprintf(stderr, "[-] Invalid input!\n");
        break;
    }
    free(enc);
    return 0;
}